// Generated by gencpp from file duco_msgs/DucoRobotState.msg
// DO NOT EDIT!


#ifndef DUCO_MSGS_MESSAGE_DUCOROBOTSTATE_H
#define DUCO_MSGS_MESSAGE_DUCOROBOTSTATE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace duco_msgs
{
template <class ContainerAllocator>
struct DucoRobotState_
{
  typedef DucoRobotState_<ContainerAllocator> Type;

  DucoRobotState_()
    : joint_expect_position()
    , joint_expect_velocity()
    , joint_expect_accelera()
    , joint_actual_position()
    , joint_actual_velocity()
    , joint_actual_accelera()
    , joint_actual_current()
    , joint_temperature()
    , driver_temperature()
    , cart_expect_position()
    , cart_expect_velocity()
    , cart_expect_accelera()
    , cart_actual_position()
    , cart_actual_velocity()
    , cart_actual_accelera()
    , slave_ready()
    , collision(false)
    , collision_axis(0)
    , emc_stop_signal(false)
    , robot_state(0)
    , robot_error(0)  {
      joint_expect_position.assign(0.0);

      joint_expect_velocity.assign(0.0);

      joint_expect_accelera.assign(0.0);

      joint_actual_position.assign(0.0);

      joint_actual_velocity.assign(0.0);

      joint_actual_accelera.assign(0.0);

      joint_actual_current.assign(0.0);

      joint_temperature.assign(0.0);

      driver_temperature.assign(0.0);

      cart_expect_position.assign(0.0);

      cart_expect_velocity.assign(0.0);

      cart_expect_accelera.assign(0.0);

      cart_actual_position.assign(0.0);

      cart_actual_velocity.assign(0.0);

      cart_actual_accelera.assign(0.0);

      slave_ready.assign(false);
  }
  DucoRobotState_(const ContainerAllocator& _alloc)
    : joint_expect_position()
    , joint_expect_velocity()
    , joint_expect_accelera()
    , joint_actual_position()
    , joint_actual_velocity()
    , joint_actual_accelera()
    , joint_actual_current()
    , joint_temperature()
    , driver_temperature()
    , cart_expect_position()
    , cart_expect_velocity()
    , cart_expect_accelera()
    , cart_actual_position()
    , cart_actual_velocity()
    , cart_actual_accelera()
    , slave_ready()
    , collision(false)
    , collision_axis(0)
    , emc_stop_signal(false)
    , robot_state(0)
    , robot_error(0)  {
  (void)_alloc;
      joint_expect_position.assign(0.0);

      joint_expect_velocity.assign(0.0);

      joint_expect_accelera.assign(0.0);

      joint_actual_position.assign(0.0);

      joint_actual_velocity.assign(0.0);

      joint_actual_accelera.assign(0.0);

      joint_actual_current.assign(0.0);

      joint_temperature.assign(0.0);

      driver_temperature.assign(0.0);

      cart_expect_position.assign(0.0);

      cart_expect_velocity.assign(0.0);

      cart_expect_accelera.assign(0.0);

      cart_actual_position.assign(0.0);

      cart_actual_velocity.assign(0.0);

      cart_actual_accelera.assign(0.0);

      slave_ready.assign(false);
  }



   typedef boost::array<double, 7>  _joint_expect_position_type;
  _joint_expect_position_type joint_expect_position;

   typedef boost::array<double, 7>  _joint_expect_velocity_type;
  _joint_expect_velocity_type joint_expect_velocity;

   typedef boost::array<double, 7>  _joint_expect_accelera_type;
  _joint_expect_accelera_type joint_expect_accelera;

   typedef boost::array<double, 7>  _joint_actual_position_type;
  _joint_actual_position_type joint_actual_position;

   typedef boost::array<double, 7>  _joint_actual_velocity_type;
  _joint_actual_velocity_type joint_actual_velocity;

   typedef boost::array<double, 7>  _joint_actual_accelera_type;
  _joint_actual_accelera_type joint_actual_accelera;

   typedef boost::array<double, 7>  _joint_actual_current_type;
  _joint_actual_current_type joint_actual_current;

   typedef boost::array<double, 7>  _joint_temperature_type;
  _joint_temperature_type joint_temperature;

   typedef boost::array<double, 7>  _driver_temperature_type;
  _driver_temperature_type driver_temperature;

   typedef boost::array<double, 7>  _cart_expect_position_type;
  _cart_expect_position_type cart_expect_position;

   typedef boost::array<double, 7>  _cart_expect_velocity_type;
  _cart_expect_velocity_type cart_expect_velocity;

   typedef boost::array<double, 7>  _cart_expect_accelera_type;
  _cart_expect_accelera_type cart_expect_accelera;

   typedef boost::array<double, 7>  _cart_actual_position_type;
  _cart_actual_position_type cart_actual_position;

   typedef boost::array<double, 7>  _cart_actual_velocity_type;
  _cart_actual_velocity_type cart_actual_velocity;

   typedef boost::array<double, 7>  _cart_actual_accelera_type;
  _cart_actual_accelera_type cart_actual_accelera;

   typedef boost::array<uint8_t, 7>  _slave_ready_type;
  _slave_ready_type slave_ready;

   typedef uint8_t _collision_type;
  _collision_type collision;

   typedef int8_t _collision_axis_type;
  _collision_axis_type collision_axis;

   typedef uint8_t _emc_stop_signal_type;
  _emc_stop_signal_type emc_stop_signal;

   typedef int8_t _robot_state_type;
  _robot_state_type robot_state;

   typedef int32_t _robot_error_type;
  _robot_error_type robot_error;





  typedef boost::shared_ptr< ::duco_msgs::DucoRobotState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::duco_msgs::DucoRobotState_<ContainerAllocator> const> ConstPtr;

}; // struct DucoRobotState_

typedef ::duco_msgs::DucoRobotState_<std::allocator<void> > DucoRobotState;

typedef boost::shared_ptr< ::duco_msgs::DucoRobotState > DucoRobotStatePtr;
typedef boost::shared_ptr< ::duco_msgs::DucoRobotState const> DucoRobotStateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::duco_msgs::DucoRobotState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::duco_msgs::DucoRobotState_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::duco_msgs::DucoRobotState_<ContainerAllocator1> & lhs, const ::duco_msgs::DucoRobotState_<ContainerAllocator2> & rhs)
{
  return lhs.joint_expect_position == rhs.joint_expect_position &&
    lhs.joint_expect_velocity == rhs.joint_expect_velocity &&
    lhs.joint_expect_accelera == rhs.joint_expect_accelera &&
    lhs.joint_actual_position == rhs.joint_actual_position &&
    lhs.joint_actual_velocity == rhs.joint_actual_velocity &&
    lhs.joint_actual_accelera == rhs.joint_actual_accelera &&
    lhs.joint_actual_current == rhs.joint_actual_current &&
    lhs.joint_temperature == rhs.joint_temperature &&
    lhs.driver_temperature == rhs.driver_temperature &&
    lhs.cart_expect_position == rhs.cart_expect_position &&
    lhs.cart_expect_velocity == rhs.cart_expect_velocity &&
    lhs.cart_expect_accelera == rhs.cart_expect_accelera &&
    lhs.cart_actual_position == rhs.cart_actual_position &&
    lhs.cart_actual_velocity == rhs.cart_actual_velocity &&
    lhs.cart_actual_accelera == rhs.cart_actual_accelera &&
    lhs.slave_ready == rhs.slave_ready &&
    lhs.collision == rhs.collision &&
    lhs.collision_axis == rhs.collision_axis &&
    lhs.emc_stop_signal == rhs.emc_stop_signal &&
    lhs.robot_state == rhs.robot_state &&
    lhs.robot_error == rhs.robot_error;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::duco_msgs::DucoRobotState_<ContainerAllocator1> & lhs, const ::duco_msgs::DucoRobotState_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace duco_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::duco_msgs::DucoRobotState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::duco_msgs::DucoRobotState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::duco_msgs::DucoRobotState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::duco_msgs::DucoRobotState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::duco_msgs::DucoRobotState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::duco_msgs::DucoRobotState_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::duco_msgs::DucoRobotState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "28ff9df01133ab7a99e78c6a90ffd27e";
  }

  static const char* value(const ::duco_msgs::DucoRobotState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x28ff9df01133ab7aULL;
  static const uint64_t static_value2 = 0x99e78c6a90ffd27eULL;
};

template<class ContainerAllocator>
struct DataType< ::duco_msgs::DucoRobotState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "duco_msgs/DucoRobotState";
  }

  static const char* value(const ::duco_msgs::DucoRobotState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::duco_msgs::DucoRobotState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float64[7]  joint_expect_position\n"
"float64[7]  joint_expect_velocity\n"
"float64[7]  joint_expect_accelera\n"
"float64[7]  joint_actual_position\n"
"float64[7]  joint_actual_velocity\n"
"float64[7]  joint_actual_accelera\n"
"float64[7]  joint_actual_current\n"
"float64[7]  joint_temperature\n"
"float64[7] driver_temperature\n"
"float64[7] cart_expect_position\n"
"float64[7] cart_expect_velocity\n"
"float64[7] cart_expect_accelera\n"
"float64[7] cart_actual_position\n"
"float64[7] cart_actual_velocity\n"
"float64[7] cart_actual_accelera\n"
"bool[7]   slave_ready\n"
"bool collision\n"
"int8 collision_axis\n"
"bool emc_stop_signal\n"
"int8 robot_state\n"
"int32 robot_error\n"
"\n"
;
  }

  static const char* value(const ::duco_msgs::DucoRobotState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::duco_msgs::DucoRobotState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.joint_expect_position);
      stream.next(m.joint_expect_velocity);
      stream.next(m.joint_expect_accelera);
      stream.next(m.joint_actual_position);
      stream.next(m.joint_actual_velocity);
      stream.next(m.joint_actual_accelera);
      stream.next(m.joint_actual_current);
      stream.next(m.joint_temperature);
      stream.next(m.driver_temperature);
      stream.next(m.cart_expect_position);
      stream.next(m.cart_expect_velocity);
      stream.next(m.cart_expect_accelera);
      stream.next(m.cart_actual_position);
      stream.next(m.cart_actual_velocity);
      stream.next(m.cart_actual_accelera);
      stream.next(m.slave_ready);
      stream.next(m.collision);
      stream.next(m.collision_axis);
      stream.next(m.emc_stop_signal);
      stream.next(m.robot_state);
      stream.next(m.robot_error);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct DucoRobotState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::duco_msgs::DucoRobotState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::duco_msgs::DucoRobotState_<ContainerAllocator>& v)
  {
    s << indent << "joint_expect_position[]" << std::endl;
    for (size_t i = 0; i < v.joint_expect_position.size(); ++i)
    {
      s << indent << "  joint_expect_position[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_expect_position[i]);
    }
    s << indent << "joint_expect_velocity[]" << std::endl;
    for (size_t i = 0; i < v.joint_expect_velocity.size(); ++i)
    {
      s << indent << "  joint_expect_velocity[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_expect_velocity[i]);
    }
    s << indent << "joint_expect_accelera[]" << std::endl;
    for (size_t i = 0; i < v.joint_expect_accelera.size(); ++i)
    {
      s << indent << "  joint_expect_accelera[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_expect_accelera[i]);
    }
    s << indent << "joint_actual_position[]" << std::endl;
    for (size_t i = 0; i < v.joint_actual_position.size(); ++i)
    {
      s << indent << "  joint_actual_position[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_actual_position[i]);
    }
    s << indent << "joint_actual_velocity[]" << std::endl;
    for (size_t i = 0; i < v.joint_actual_velocity.size(); ++i)
    {
      s << indent << "  joint_actual_velocity[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_actual_velocity[i]);
    }
    s << indent << "joint_actual_accelera[]" << std::endl;
    for (size_t i = 0; i < v.joint_actual_accelera.size(); ++i)
    {
      s << indent << "  joint_actual_accelera[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_actual_accelera[i]);
    }
    s << indent << "joint_actual_current[]" << std::endl;
    for (size_t i = 0; i < v.joint_actual_current.size(); ++i)
    {
      s << indent << "  joint_actual_current[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_actual_current[i]);
    }
    s << indent << "joint_temperature[]" << std::endl;
    for (size_t i = 0; i < v.joint_temperature.size(); ++i)
    {
      s << indent << "  joint_temperature[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.joint_temperature[i]);
    }
    s << indent << "driver_temperature[]" << std::endl;
    for (size_t i = 0; i < v.driver_temperature.size(); ++i)
    {
      s << indent << "  driver_temperature[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.driver_temperature[i]);
    }
    s << indent << "cart_expect_position[]" << std::endl;
    for (size_t i = 0; i < v.cart_expect_position.size(); ++i)
    {
      s << indent << "  cart_expect_position[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.cart_expect_position[i]);
    }
    s << indent << "cart_expect_velocity[]" << std::endl;
    for (size_t i = 0; i < v.cart_expect_velocity.size(); ++i)
    {
      s << indent << "  cart_expect_velocity[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.cart_expect_velocity[i]);
    }
    s << indent << "cart_expect_accelera[]" << std::endl;
    for (size_t i = 0; i < v.cart_expect_accelera.size(); ++i)
    {
      s << indent << "  cart_expect_accelera[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.cart_expect_accelera[i]);
    }
    s << indent << "cart_actual_position[]" << std::endl;
    for (size_t i = 0; i < v.cart_actual_position.size(); ++i)
    {
      s << indent << "  cart_actual_position[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.cart_actual_position[i]);
    }
    s << indent << "cart_actual_velocity[]" << std::endl;
    for (size_t i = 0; i < v.cart_actual_velocity.size(); ++i)
    {
      s << indent << "  cart_actual_velocity[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.cart_actual_velocity[i]);
    }
    s << indent << "cart_actual_accelera[]" << std::endl;
    for (size_t i = 0; i < v.cart_actual_accelera.size(); ++i)
    {
      s << indent << "  cart_actual_accelera[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.cart_actual_accelera[i]);
    }
    s << indent << "slave_ready[]" << std::endl;
    for (size_t i = 0; i < v.slave_ready.size(); ++i)
    {
      s << indent << "  slave_ready[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.slave_ready[i]);
    }
    s << indent << "collision: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.collision);
    s << indent << "collision_axis: ";
    Printer<int8_t>::stream(s, indent + "  ", v.collision_axis);
    s << indent << "emc_stop_signal: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.emc_stop_signal);
    s << indent << "robot_state: ";
    Printer<int8_t>::stream(s, indent + "  ", v.robot_state);
    s << indent << "robot_error: ";
    Printer<int32_t>::stream(s, indent + "  ", v.robot_error);
  }
};

} // namespace message_operations
} // namespace ros

#endif // DUCO_MSGS_MESSAGE_DUCOROBOTSTATE_H
